## 1.盒子阴影



#### 1.1 语法

​	`box-shadow: h-shadow v-shadow blur spread color inset;`

​	h-shadow:  必须，水平阴影的位置，正值向右，负值向左

​	v-shadow: 必须，垂直阴影位置，正值向上，负值向下

​	blur: 可选，模糊距离（模糊程度）

​	spread: 可选，阴影尺寸（大小）

​	color: 可选，阴影颜色

​	Inset: 可选，将外部阴影（outset) 改为内部阴影

#### 1.2 注意

* 默认是外阴影（outset），但是不可以添加这个单词，否则导致阴影无效
* 盒子阴影不占用空间，不会影响其他盒子排列

阴影颜色 **rgba(0,0,0,.3)**最后面的.3表示透明程度



## 2.CSS3新特性



### 2.1 2D转换



#### 2.1.1 二维坐标系

​	X轴水平向右，Y轴水平向下

#### 2.1.2移动 translate

1. 语法

​			`transform: translate(x,y);`

​			或者分开写

​			`transform: translateX(n);`  

​			`transform: translateY(n);`

​			括号内可为像素单位，也可以是百分比，负号表示与正方向相反

2. 重点

   * 定义2D转换中的移动，沿着X和Y轴移动元素

   * translate最大的优点： 不会影响到其他盒子

   * translate中的百分比单位是相对于自身元素的

   * **对行内元素没有效果**

#### 2.1.3  旋转 rotate



 1. 语法

    `transform: rotate(度数)`

 2. 重点

    * rotate里面跟度数，单位为 deg
    * 度数为正时，顺时针，负时，逆时针
    * 默认转换的中心点是元素的中心点

	3. 转换中心点 transform-origin

    * 语法

      `transform-origin: x y;`

    * 重点
      * 注意后面的参数x和y用空格隔开
      * x y ，默认转换的中心点是元素的中心点 （50% 50%）
      * 还可以给x y 设置 像素 或者 方位名词 （ top bottom left right center）

#### 2.1.4 缩放scale

1. 语法

   `transform: scale(x,y);`

2. 注意

   * 注意其中x和y 用逗号分隔

   * `transform: scale(1,1);`

     相当于宽和高都放大一倍，相对于没有放大

   * `taansform: scale(2,2)`

     相当于宽和高都放大2倍

   * `transform: scale(2)`

     只写一个参数，默认第二个参数跟第一个一样

   * `transform: scale(0.5,0.5)`

     缩小0.5倍

   * scale缩放最大的优势在于可以设置转换中心点，默认为中心，而且不影响其他盒子



## 3、轮播图制作

### 3.1 功能需求

1. 点击右侧按钮一次，图片往左播放一张，右侧按钮同理
2. 图片播放时，下面小圆圈模块跟着一起变化
3. 点击小圆圈，可以播放对应的图片啊
4. 鼠标不经过轮播图，轮播图会自动播放图片
5. 鼠标经过时，自动播放停止

### 3.2 案例分析

#### 3.2.1 动态生成小圆圈

1. 核心思路：小圆圈的个数要跟图片张数一致
2. 作用： 当再添加图片时，会自动生成小圆圈，不用手动去添加
3. 以首先先得到`ul`里面图片的张数（图片放入li里面，所以就是li的个数）
4. 利用循环动态生成小圆圈（这个小圆圈要放入`ol`里面）
5. 创建节点 `createElement(‘li’)`
6. 插入节点 `ol. appendChild(li)`
7. 第一个小圆圈需要添加 current 类，`**css**`中给该类添加样式

#### 3.2.2 小圆圈的排他思想

1. 点击当前小圆圈，就添加current类  
2. 其余的小圆圈就移除这个current类 
3. 注意： 我们在刚才生成小圆圈的同时，就可以直接绑定这个点击事件了

#### 3.2.3 点击小圆圈滚动图片

1. 此时用到`animate`动画函数，将`js`文件引入（注意，因为`index.js` 依赖 `animate.js` 所以，`animate.js` 要写到 `index.js` 上面）
2. 使用动画函数的前提，该元素必须有定位
3. 注意是`ul` 移动 而不是小`li` 
4. 滚动图片的核心算法： 点击某个小圆圈 ， 就让图片滚动 小圆圈的**索引号乘以图片的宽度**做为`ul`移动距离
5. 此时需要知道小圆圈的索引号， 我们可以在生成小圆圈的时候，给它设置一个自定义属性，点击的时候获取这个自定义属性即可。

#### 3.2.4 点击右侧按钮一次，图片滚动一张

1. 声明一个变量`num`， 点击一次，自增1， 让这个变量乘以图片宽度，就是 `ul` 的滚动距离。

2. 图片无缝滚动原理

   * 把`ul` 第一个li 复制一份，放到`ul` 的最后面

   * 当图片滚动到克隆的最后一张图片时， 让`ul` 快速的、不做动画的跳到最左侧： `left 为0` 

   * 同时`num` 赋值为0，可以从新开始滚动图片了

#### 3.2.5 克隆第一张照片

1. 克隆`ul` 第一个li `cloneNode()` 加`true` 深克隆 复制里面的子节点 `false` 浅克隆
2. 添加到 `ul` 最后面 `appendChild`
3. 若不把第一张图克隆放在最后面的话，当播放到最后一张图片时，由上一步可知，`ul`会快速跳到最左侧，此时再点击会把最前面一张图片跳过

#### 3.2.6 点击按钮，小圆圈跟着变化

1. 最简单的做法是再声明一个变量circle，每次点击自增1，注意，左侧按钮也需要这个变量，因此要声明**全局变量**
2. 但是图片有5张，我们小圆圈只有4个少一个，必须加一个判断条件
3. 如果circle == 4 就 从新复原为 0

#### 3.2.7 自动播放功能

1. 添加一个定时器
2. 自动播放轮播图，实际就类似于点击了右侧按钮
3. 此时我们使用手动调用右侧按钮点击事件 `arrow_r.click()` 
4. 鼠标经过轮播图就停止定时器
5. 鼠标离开轮播图就开启定时器

#### 3.2.8 节流阀

**防止轮播图按钮连续点击造成播放过快。**

1. 节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。

2. 核心实现思路：**利用回调函数，添加一个变量来控制，锁住函数和解锁函数**。

3. 开始设置一个变量 `var flag = true;`

   * `If(flag) {flag = false; do something}` 关闭水龙头

   * 利用回调函数 动画执行完毕，` flag = true `打开水龙头

### 3.3 代码展示

```javascript
	var arrow_l = document.querySelector('.arrow-l');
    var arrow_r = document.querySelector('.arrow-r');
    var focus = document.querySelector('.focus');
    var ul = focus.querySelector('ul');
    var ol = focus.querySelector('.circle');
    var focusWidth = focus.offsetWidth;  //获得父盒子的宽度

    for (var i = 0; i < ul.children.length; i++) {
        var li = document.createElement('li');
        li.setAttribute('index', i);   // 记录当前小圆圈的索引号
        ol.appendChild(li);
        ol.children[i].addEventListener('click', function () {
            for (var j = 0; j < ol.children.length; j++) {
                ol.children[j].className = '';
            }
            this.className = 'current';
            // 点击圆圈实现滚动
            var index = this.getAttribute('index');
            // 当我们点击某个Li,把索引号给num
            num = index;
            // 当我们点击某个li，把索引号给circle
            circle = index;
            animate(ul, - focusWidth * index);
        })
    }
    ol.children[0].className = 'current';
    // 克隆第一张图片放到ul坐后面
    var first = ul.children[0].cloneNode(true);   // 克隆包括子节点
    ul.appendChild(first);
    // 点击箭头实现滚动图片
    var num = 0;
    var circle = 0;
    // flag 节流阀
    var flag = true;
    arrow_r.addEventListener('click', function () {
       if (flag) {
           flag = false; //关闭节流阀
        if (num == ul.children.length - 1) {
            ul.style.left = 0;
            num = 0;
        }
        num++;
        animate(ul, -num * focusWidth, function() {
            flag = true;   // 等到动画结束后再打开节流阀
        });
        // 点击右侧小箭头，小圆圈也跟着变化
        circle++;
        if (circle == ol.children.length) {  //注意是ol长度，比ul长度少1
            circle = 0;
        }
        for (var i = 0; i < ol.children.length; i++) {
            ol.children[i].className = '';
        }
        ol.children[circle].className = 'current';
    }
    })
    // 最后，实现自动播放轮播图
    var timer = setInterval(function() {
        // 手动调用点击事件
        arrow_r.click();
    }, 2000);
    // 鼠标经过时停止自动播放
    focus.addEventListener('mouseenter', function() {
        clearInterval(timer);
        timer = null;
    });
    // 鼠标离开时自动播放
    focus.addEventListener('mouseleave', function() {
        timer = setInterval(function() {
            arrow_r.click();
        }, 2000);
    });

// 点击左侧箭头实现播放图片
    arrow_l.addEventListener('click', function () {
        if (flag) {
            flag = false; //关闭节流阀
         if (num == 0) {
             num = ul.children.length-1;
             ul.style.left = -(ul.children.length-1) * focusWidth + 'px';
         }
         num--;
         animate(ul, -num * focusWidth, function() {
             flag = true;   // 等到动画结束后再打开节流阀
         });
         // 点击右侧小箭头，小圆圈也跟着变化
         circle--;
         if (circle < 0) {
             circle = ol.children.length-1;
         }
         for (var i = 0; i < ol.children.length; i++) {
             ol.children[i].className = '';
         }
         ol.children[circle].className = 'current';
        }
     })
```














